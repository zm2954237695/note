### 一. spring核心注解

#### @Required

此注解用于bean的setter方法上。表示此属性是必须的，必须在配置阶段注入，否则会抛出BeanInitializationExcepion。

#### @Autowired

此注解用于bean的field、setter方法以及构造方法上，显式地声明依赖。根据type来autowiring。
当在field上使用此注解，并且使用属性来传递值时，Spring会自动把值赋给此field。也可以将此注解用于私有属性，如下。

```java
@Component
public
class User {
    @Autowired
    private Address address;
}

```

```java
@Component
public class User {
    private Address address;

    @AutoWired
    public setAddress(Address address) {
        // custom code
        this.address = address;
    }
}

```

**注意事项：**

　　在使用@Autowired时，首先在容器中查询对应类型的bean

　　　　如果查询结果刚好为一个，就将该bean装配给@Autowired指定的数据

　　　　如果查询的结果不止一个，那么@Autowired会根据名称来查找。

　　　　如果查询的结果为空，那么会抛出异常。解决方法时，使用required=false

**@Autowired的原理是什么？**

　　其实在启动spring IoC时，容器自动装载了一个AutowiredAnnotationBeanPostProcessor后置处理器，当容器扫描到@Autowied、@Resource(是CommonAnnotationBeanPostProcessor后置处理器处理的)或@Inject时，就会在IoC容器自动查找需要的bean，并装配给该对象的属性

```xml
 <bean class="org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor"/>  
```

#### @Qualifier

此注解是和@Autowired一起使用的。使用此注解可以让你对注入的过程有更多的控制。

@Qualifier可以被用在单个构造器或者方法的参数上。当上下文有几个相同类型的bean（一个接口有多个实现类的情况）, 使用@Autowired则无法区分要绑定的bean，此时可以使用@Qualifier来指定名称。

```java
@Component
public class User {
    @Autowired
    @Qualifier("address1")
    private Address address;
}

```

## @Configuration

用于定义配置类，可替换xml配置文件，被注解的类内部包含有一个或多个被@Bean注解的方法，这些方法将会被AnnotationConfigApplicationContext或AnnotationConfigWebApplicationContext类进行扫描，并用于构建bean定义，初始化Spring容器。

## @ComponentScan

此注解一般和@Configuration注解一起使用，指定Spring扫描注解的package。如果没有指定包，那么默认会扫描此配置类所在的package。

**基本用法**

```java
@Configuration
@ComponentScan(value = "com.atguigu")
public class SpringConfig {
}
```

#### 排除

```java
@Configuration
/**
 * @ComponentScan 包扫描注解
 *   value：指定要扫描的包
 *   excludeFilters: 指定扫描时排除哪些
 */
@ComponentScan(value = "com.atguigu", excludeFilters = {
        /**
         * excludeFilters是一个Filter类型的数组
         *    type：过滤规则
         */
        @ComponentScan.Filter(type = FilterType.ANNOTATION, classes = {Controller.class})
})
public class SpringConfig {
}

```

**只包含**

```java
/**
 * @ComponentScan 包扫描注解
 *  value：指定要扫描的包
 *  includeFilters: 扫描时只扫描哪些
 *  useDefaultFilters:禁用默认扫描规则，否则includeFilters不生效
 */
@ComponentScan(value = "com.atguigu", includeFilters = {
        /**
         * includeFilters是一个Filter类型的数组
         *   type：过滤规则
         */
        @ComponentScan.Filter(type = FilterType.ANNOTATION, classes = {Controller.class}),
        @ComponentScan.Filter(type = FilterType.ASSIGNABLE_TYPE, classes = {BookService.class}),
        @ComponentScan.Filter(type = FilterType.CUSTOM, classes = {MyTypeFilter.class})
}, useDefaultFilters = false)
public class SpringConfig {
}

```

@Lazy
此注解使用在Spring的组件类上。默认的，Spring中Bean的依赖一开始就被创建和配置。如果想要延迟初始化一个bean，那么可以在此类上使用Lazy注解，表示此bean只有在第一次被使用的时候才会被创建和初始化。此注解也可以使用在被@Configuration注解的类上，表示其中所有被@Bean注解的方法都会延迟初始化。

```java
@Configuration
@ComponentScan("com.atguigu.controller")
public class SpringConfig {
    @Scope(ConfigurableBeanFactory.SCOPE_SINGLETON)
    @Lazy
    @Bean("person")
    public Person person() {
        System.out.println("Person实例被创建");
        return new Person();
    }
}

```

```java
@Controller
@Lazy
@Scope(ConfigurableBeanFactory.SCOPE_SINGLETON)
public class BookController {
    public BookController() {
        System.out.println("BookController实例被创建");
    }
}

```

@Value
此注解使用在字段、构造器参数和方法参数上。@Value可以指定属性取值的表达式，支持通过#{}使用SpringEL来取值，也支持使用${}来将属性来源中(Properties文件、本地环境变量、系统属性等)的值注入到bean的属性中。此注解值的注入发生在AutowiredAnnotationBeanPostProcessor类中。

```java
@Component
@Data
// 读取配置文件，将其中k/v保存到运行环境变量
@PropertySource(value = {"classpath:/person.properties"})
public class Person {
    /**
     * @Value 可取值有：
     * 1 基本数据类型
     * 2 SpEL表达式： #{}
     * 3 取配置文件（运行环境变量里的值）的值：${}
     */
    @Value("张三")
    private String name;
    @Value("#{20 - 2}")
    private Integer age;
    @Value("${person.address}")
    private String address;
}

```

# 二. Spring MVC注解

## @Controller

此注解使用在class上声明此类是一个Spring controller，是@Component注解的一种具体形式。

#### @RequestMapping

此注解可以用在class和method上，用来映射web请求到某一个handler类或者handler方法上。当此注解用在Class上时，就创造了一个基础url，其所有的方法上的@RequestMapping都是在此url之上的。

可以使用其method属性来限制请求匹配的http method。

```java
@RequestMapping("/testRequestMapping")
@Controller
public class TestRequestMapping {
    private static final String SUCCESS = "success";
    /**
     * 请求url : .../testRequestMapping/base
     */
    @RequestMapping("/base")
    public String base() {
        System.out.println("TestRequestMapping.base()");
        return SUCCESS;
    }
}

```

```java
/**
 * method 映射请求方法
 * 该方法可以映射POST类型的请求
 */
@RequestMapping(value = "/post",method = RequestMethod.POST)
public String requestMethod() {
    System.out.println("TestRequestMapping.requestMethod()");
    return SUCCESS;
}

```

此外，Spring4.3之后引入了一系列@RequestMapping的变种。如下：

```java
@GetMapping
@PostMapping
@PutMapping
@PatchMapping
@DeleteMapping
```

#### @CookieValue

此注解用在@RequestMapping声明的方法的参数上，可以把HTTP cookie中相应名称的cookie绑定上去。

```java
@RequestMapping("/testCookieValue")
@Controller
public class TestCookieValue {
    private static final String SUCCESS = "success";

    @RequestMapping("/getCookie")
    public String getCookie(@CookieValue("JSESSIONID") String JSESSIONID) {
        System.out.println("JSESSIONID = " + JSESSIONID);
        return SUCCESS;
    }
}

```

## @ExceptionHandler

此注解使用在方法级别，声明对Exception的处理逻辑。可以指定目标Exception。

```java
@ControllerAdvice //springMVC 全局异常处理
public class MyExceptionHandler1 {
    //浏览器和客户端返回的都是json数据没有自适应效果
    @ResponseBody
    @ExceptionHandler(UserNotExistException.class) // 处理异常的类型
    public Map<String, Object> handleException(Exception e) {
        Map<String, Object> map = new HashMap<>();
        map.put("code", "user notExist");
        map.put("message", e.getMessage());
        return map;
    }
}

```

三. Spring Boot注解

#### @EnableAutoConfiguration

此注解通常被用在主应用class上，告诉Spring Boot自动基于当前包添加Bean、对bean的属性进行设置等。

#### @SpringBootApplication

此注解用在Spring Boot项目的应用主类上（此类需要在base package中）。使用了此注解的类首先会让Spring Boot启动对base package以及其sub-pacakage下的类进行component scan。

此注解同时添加了以下几个注解：

```java
@Configuration
@EnableAutoConfiguration
@ComponentScan
```

