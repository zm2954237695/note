# 获取省市区列表

### 1 获取省市区列表 - 数据库

### 2 获取省市区列表 - 实体类

```java
   private Integer id;
    private String parent;
    private String code;
    private String name;
```

### 3 获取省市区列表-持久层

查询语句,根据父代号进行查询

```sql
select * from t_dict_district where parent = ? order by code ASC
```

抽象方法定义和编写mapper.xml文件

```java
public interface DistrictMapper {
    List<District> findByParent(Integer parent);
}
```

#### 单元测试

```java
@SpringBootTest
@RunWith(SpringRunner.class)
public class DistMapperTests {

    @Autowired
    private DistrictMapper districtMapper;

    @Test
    public void findByParent(){
        List<District> list = districtMapper.findByParent("210100");
        for (District district : list) {
            System.out.println(district);
        }
    }



}

```

### 获取省市区列表 - 业务层

1.创建接口IDistrictService,并定义抽象方法

```java
public interface IDistrictService {
    List<District> getByParent(String parent);
}

```

### 4 获取省市区列表 - 控制层

#### 4.1 设计请求

```http
/districts/
GET
String parent
JsonResult<List<District>>
```

4.2 编写请求

```java
@RequestMapping("districts")
@RestController
public class DistrictController extends BaseController{

    @Autowired
    private IDistrictService districtService;

    @RequestMapping({"/",""})
    public JsonResult<List<District>> getByParent(String parent){

        List<District> data = districtService.getByParent(parent);
        return new JsonResult<>(OK,data);

    }


}
```

### 5 获取省市区列表 前端页面

1. 注释掉通过js来完成省市区列表加载的js代码

```html
<!--
<script type="text/javascript" src="../js/distpicker.data.js"></script>
<script type="text/javascript" src="../js/distpicker.js"></script>
-->
```

2. 检查前端页面在提交省市区数据时是否有相关name属性和id属性。
3. 运行前端看是否还可以正常保存数据(除了省市区之外)

### 获取省市区的名称

#### 获取省市区的名称 - 持久层

1.规划根据当前code来获取当前省市区的名称，对应就是一条查询语句。

```sql
select * from t_district where code = ?
```

2.在DistrictMapper接口中定义出来。

3.在DistrictMapper.xml添加抽象方法的映射。

4.单元测试

```java
 @Test
    public void findNameByCode(){
        String name  = districtMapper.findNameByCode("610000");
       System.out.println(name);
   }
```

#### 获取省市区的名称 - 业务层

1. 在业务层中没有异常需要处理。
2. 定义对应的业务层接口中的抽象方法。

  3.在子类进行实现。

```java
@Override
    public String getNameByCode(String code)    {
        return     districtMapper.findNameByCode(code);
    }
```

#### 获取省市区的名称 - 业务层

1. 添加地址层依赖于IDistrictService层.

```java
//在添加用户的收货地址的业务层依赖于IDistrictService的业务层接口.
@Autowired
private IDistrictService districtService;
```

2在addNewAddress方法中将districtService接口中获取到的省市区数据转移到address对象，这个对象就包含了所有的用户收货地址的数据。

### 收货地址列表展示

#### 1. 持久层

```sql
select * from t_address where uid=? order by
is_default DESC, created_time DESC
```

#### 2.接口和抽象方法

#### 3.在xml中添加相应的sql语句映射.

### 2.业务层

#### 1.不用抛出相关的异常,不用进行异常的设计.

#### 2.设计业务层的接口和抽象方法。

#### 3. 实现该方法

```java
  public List<Address> getByUid(Integer uid) {
        List<Address>list = addressMapper.findByUid(uid);
        for (Address address : list) {
            address.setUid(null);
            address.setAid(null);
            address.setProvinceCode(null);
            address.setCityCode(null);
            address.setAreaCode(null);
            address.setTel(null);
            address.setCreatedTime(null);
            address.setCreatedUser(null);
            address.setIsDefault(null);
            address.setModifiedTime(null);
            address.setModifiedUser(null);
        }
        return list;
    }
```

### 控制层

#### 1.请求设计

```http
/addresses
HttpSession session
GET
JsonResult<List<Address>>
```

#### 2.实现请求方法的编写.

```java
@RequestMapping({"","/"})
    public JsonResult<List<Address>>getByUid(HttpSession session){
        Integer uid = getuidFromSession(session);
        List<Address> data = addressService.getByUid(uid);
        return new JsonResult<>(OK,data);
}
```



