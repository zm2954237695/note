#### [222. 完全二叉树的节点个数](https://leetcode-cn.com/problems/count-complete-tree-nodes/)

难度中等

给你一棵 **完全二叉树** 的根节点 `root` ，求出该树的节点个数。

[完全二叉树](https://baike.baidu.com/item/完全二叉树/7773232?fr=aladdin) 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 `h` 层，则该层包含 `1~ 2h` 个节点。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/01/14/complete.jpg)

```
输入：root = [1,2,3,4,5,6]
输出：6
```

**示例 2：**

```
输入：root = []
输出：0
```

**示例 3：**

```
输入：root = [1]
输出：1
```

 

**提示：**

- 树中节点的数目范围是`[0, 5 * 10^4]`
- `0 <= Node.val <= 5 * 10^4`
- 题目数据保证输入的树是 **完全二叉树**

 

**进阶：**遍历树来统计节点是一种时间复杂度为 `O(n)` 的简单解决方案。你可以设计一个更快的算法吗？



```
思路：一般是思路可以递归地求左节点的个数+右节点的个数+1就是题目所求，但是时间复杂度为O(N),由于本题给的树比较特殊，是完全二叉树，求树的高度可以logN的复杂度求出来，然后分类讨论，通过画图可以知道，如果左右子树高度相同，那么左子树必为完美二叉树，其节点个数为(1<<l)-1,加上根节点，个数为(1<<l),然后再用同样的方法计算右指数，两者相加便是答案。否则，则是右子树为完美二叉树，其节点个数为(1<<(l-1))，通过用这种方法递归计算左右子树的节点个数，其时间复杂度为O(log(n^2))
```

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    private int height(TreeNode root){
        if(root==null){
            return 0;
        }
        return 1+height(root.left);
    }
    public int countNodes(TreeNode root) {
        if(root==null){
            return 0;
        }
        int l=height(root.left);
        int r=height(root.right);
        if(l==r){
            return (1<<l)+countNodes(root.right);
        }else {
            return (1<<(l-1))+countNodes(root.left);
        }
    }
}
```

