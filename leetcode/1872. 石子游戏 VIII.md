#### [1872. 石子游戏 VIII](https://leetcode-cn.com/problems/stone-game-viii/)

难度困难31

Alice 和 Bob 玩一个游戏，两人轮流操作， **Alice 先手** 。

总共有 `n` 个石子排成一行。轮到某个玩家的回合时，如果石子的数目 **大于 1** ，他将执行以下操作：

1. 选择一个整数 `x > 1` ，并且 **移除** 最左边的 `x` 个石子。
2. 将 **移除** 的石子价值之 **和** 累加到该玩家的分数中。
3. 将一个 **新的石子** 放在最左边，且新石子的值为被移除石子值之和。

当只剩下 **一个** 石子时，游戏结束。

Alice 和 Bob 的 **分数之差** 为 `(Alice 的分数 - Bob 的分数)` 。 Alice 的目标是 **最大化** 分数差，Bob 的目标是 **最小化** 分数差。

给你一个长度为 `n` 的整数数组 `stones` ，其中 `stones[i]` 是 **从左边起** 第 `i` 个石子的价值。请你返回在双方都采用 **最优** 策略的情况下，Alice 和 Bob 的 **分数之差** 。

 

**示例 1：**

```
输入：stones = [-1,2,-3,4,-5]
输出：5
解释：
- Alice 移除最左边的 4 个石子，得分增加 (-1) + 2 + (-3) + 4 = 2 ，并且将一个价值为 2 的石子放在最左边。stones = [2,-5] 。
- Bob 移除最左边的 2 个石子，得分增加 2 + (-5) = -3 ，并且将一个价值为 -3 的石子放在最左边。stones = [-3] 。
两者分数之差为 2 - (-3) = 5 。
```

**示例 2：**

```
输入：stones = [7,-6,5,10,5,-2,-6]
输出：13
解释：
- Alice 移除所有石子，得分增加 7 + (-6) + 5 + 10 + 5 + (-2) + (-6) = 13 ，并且将一个价值为 13 的石子放在最左边。stones = [13] 。
两者分数之差为 13 - 0 = 13 。
```

**示例 3：**

```
输入：stones = [-10,-12]
输出：-22
解释：
- Alice 只有一种操作，就是移除所有石子。得分增加 (-10) + (-12) = -22 ，并且将一个价值为 -22 的石子放在最左边。stones = [-22] 。
两者分数之差为 (-22) - 0 = -22 。
```

 

**提示：**

- `n == stones.length`
- `2 <= n <= 105`
- `-104 <= stones[i] <= 104`

```java
思路：由于本题n给的数据范围是1e5,因此时间复杂度为O(N)或O(nlogn),然后题目不需要用到排序，所以大概就是On的时间复杂度了。本题求两个人最大的分数差，经过分析，题目等价于已经取过的石头并不会消失，又是还在"原地”，只是下一轮的玩家只能从该石头的下一位置去石子。后面玩家的状态(子问题的答案)取决于前面状态的答案，结合时间复杂度，可以知道该算法为线性DP，因此可以定义dp[i]，表示到了位置i的分数最大差值，那么最终问题的答案就是max(dp[2],dp[3]...dp[n-1),不难发现，
dp[i]=sum[0:i]-max(dp[i+1],dp[i+2]...dp[n-1])
   在计算dp[i]的同时又要去计算dp[i+1],dp[i+2]..dp[n-1],因此时间复杂度又变成了O(n^2)，显然会超时。
 --需要转变思路
    我们在计算得到dp[n]的时候，也就是现在得到的最优答案，可以先保存在一个变量best里面.那么就有如下式子:
    best=dp[n]
    dp[n-1]=sum(0:n-1])-best
    best=dp[n-1]
    dp[n-2]=sum(0:n-2)-best
        
    .....
        
     通过倒序循环，先求出后面的最优解，反过来推前面的状态.
      dp[i] = sum[0:i] - best
     

```

具体代码如下：

```java
class Solution {
    public int stoneGameVIII(int[] stones) {
        int n=stones.length;
        for(int i=1;i<n;i++){
            stones[i]+=stones[i-1];
        }
        int ans=stones[n-1];
        for(int i=n-1;i>=2;i--){
            ans=Math.max(ans,stones[i-1]-ans);
        }
        return ans;
    }
}
```

