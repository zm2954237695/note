### 单例模式

- 单例类只有一个实例。
- 单例类必须自己实例化自己。
- 单例类需要向外提供实例。

#### 饿汉式

```java
public class EagerSingleton {
    private static EagerSingleton instance = new EagerSingleton();
    private EagerSingleton(){}
    public static EagerSingleton getInstance(){
        return instance;
    }
}
```

上面是饿汉式单例模式的标准代码，所谓的“饿汉式”只是形象的比喻：EagerSingleton类的实例因为变量instance申明为static的关系，在类加载过程中便会执行。由此带来的好处是Java的类加载机制本身为我们保证了实例化过程的线程安全性，缺点是这种空间换时间的方式，即使类实例本身还未用到，实例也会被创建。

饿汉式的缺点有2：

- 空间使用率不高
- 类加载时实例化，意味着该类无法在程序运行过程中通过运行参数实例化，代码失去灵活性。 

饿汉式在当前硬件设备条件下，缺点其实关系不大，对于空间不是特别严苛的应用来说，且用不到初始化参数的类型来说，建议使用这种方式。



# 懒汉式

“懒汉式”是针对饿汉式单例模式缺点而生的懒加载模式，所谓懒加载的意思是，只有当需要使用实例的时候才去实例化。来看看示例代码：

```java
public class LazySingleton {
    private static LazySingleton instance = null;
    private LazySingleton(){}
    public static LazySingleton getInstance(){
        if(instance==null){
            instance = new LazySingleton();
        }
        return instance;
    }
}
```

饿汉式和懒汉式的区别在于，饿汉式在类加载时便被实例化，而懒汉式是在getInstance()函数调用时，相信你也能看出来，当instance == null 时，去实例化，否则直接返回实例。

但这里有个问题，单例模式的核心是系统中只存在一个单例类的实例，这其实隐含了实例只创建一次的意思。但上述LazySingleton类只能保证在单线程中只创建一次，**在多线程中却不能保证**。

如果有两个线程，Thread1、Thread2，两个线程先后调用getInstance()函数。如果Thread1的调用，执行到if(instance == null)的语句块中被中断，此时instance的值还未改变，Thread2也执行到了这里，可以预见，两个线程都将分别创建一个LazySingleton实例，最终instance的值是那个线程创建的实例，将是不确定的。

这个缺点的原因，涉及到并发编程的原子性。实例中，创建实例的代码逻辑失去了原子性从而导致可能存在多个实例创建的情况。

既然这样，可以通过对该实例方法进行加锁。

```java
public class LazySingleton {
    private static LazySingleton instance = null;
    private LazySingleton(){}
    public static synchronized LazySingleton getInstance(){
        if(instance==null){
            instance = new LazySingleton();
        }
        return instance;
    }
}
```

在`getInstance()`函数申明上加`synchronized`，意味着每次函数调用都会进行同步检查，这是低效的。实际上，我们只需要保证创建实例代码的原子性即可。

```java
if(instance == null){
    instance = new LazySingleton(); // 懒加载
}
```

也就是说，这种实现方案的同步范围扩大了，这个问题由双重检查锁来解决。

# 双重检查锁

在前面，我们在`getInstance()`加了`synchronized`，扩大了同步范围，现在我们来减小一下同步范围：

```java
public class Singleton {
    private volatile static Singleton instance = null;
    private Singleton(){}
    public static Singleton getInstance(){
        //先检查实例是否存在，如果不存在才进入下面的同步块
        if(instance == null){
            //同步块，线程安全的创建实例
            synchronized (Singleton.class) {
                //再次检查实例是否存在，如果不存在才真正的创建实例
                if(instance == null){
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}

```

所谓的**双重检查**，是在同步前后的两次`if(instance == null)`判断，是否已经存在实例，**锁**自然指的就是`synchronized`关键字。



代码在编译时，存在指令优化的现象。指令优化只保证单线程条件下执行结果一致，而不保证执行的顺序。所以前面三个指令的执行顺序是不确定的，可能是1-2-3，也可以是1-3-2。如果顺序是1-3-2，当第三步执行完后，instance已经不为空了，但成员并未初始化，第二个线程使用该instance自然会报错。怎么解决呢？

**volatile可以解决这个问题**，该关键字可以确保相关变量涉及的代码指令不被优化顺序。

### 静态内部类

```java
public class Singleton {
    private Singleton(){}
    private static class SingletonHolder{
        private static Singleton instance = new Singleton();
    }
    public static Singleton getInstance(){
        return SingletonHolder.instance;
    }

}

```

- 线程安全：由静态内部类中的静态成员初始化时创建实例，通过JVM类加载机制来保证线程的安全性。
- 懒加载：使用静态内部类的方式，让类`SingletonHolder`只有在使用的时候才会被加载，实例才会创建，借机实现了懒加载。

```java
public enum SingletonEnum {
    uniqueInstance;
    public void SingletonOperation(){}
    
}
```

