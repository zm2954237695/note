1. ##### ArrayList扩容机制:

   - ArrayList()会使用长度为0的数组
   - ArrayList(int initialCapacity)会使用指定容量的数组
   - public ArrayList(Collection<? extends E>c)会使用c的大小作为数组容量
   - add(Object o)首次扩容为10，再次扩容为上次容量的1.5倍(底层通过以下公式计算： 原容量>>1+原容量)
   - addAll(Collection c)没有元素时，扩容为Math.max(10,实际元素个数),有元素时扩容为Math.max(实际元素元素，原容量的1.5倍)

   ##### 2. fail-fast与fail-safe

   - ArrayList是fail-fast的典型代表，遍历的同时不允许修改，否则就会抛出并发异常(ConcurrentModificationException)，尽快失败.
   - copyOnWriteArrayList是fail-safe的典型代表.遍历的同时可以修改，(内部会使用两个数组，遍历的用的是旧数组，对集合的修改用作用于新数组),原理是读写分离。

   ##### 3.  ArrayList与LinkedList

   - ArrayList
     - 基于数组，需要连续内存
     - 随机访问快
     - 尾部插入，删除性能可以，其他部分插入，删除都会移动数据，因此性能低
     - 可以利用cpu缓存，局部性原理
   - LinkedList
     - 基于双向链表，无需连续内存
     - 随机访问慢(要沿着链表遍历)
     - 头尾插入删除性能高
     - 占用内存多

   ##### 4. HashMap

   - 底层数据结构,1.7与1.8有何不同？

       1.7 数组+链表, 1.8  数组+(链表|红黑树)

   - 为何要用红黑树，为何一上来不树化，树化阀值为何是8，何时会树化，何时会退化为链表

     ①  红黑树用来避免Dos攻击，防止链表超长时性能下降，<b>树化应当是偶然情况</b>。

     ​       ①  hash表的查找，更新的时间复杂度是O（1），而红黑树的查找，更新的时间复杂度是O(logN),TreeNode占用空间也比普通Node的大，如非必要，尽量还是使用链表

     ​       ②  hash值如果足够随机,则在hash表内按泊松分布，在负载因子0.75的情况下，长度超过8的链表出现的概率是0.00000006，选择8就是为了树化几率足够小。

     ②  树化两个条件： 链表长度超过树化阀值；数组容量>=64

     ③  退化情况1：在扩容时如果拆分树时，树元素个数<=6则会退化成链表。

     ④  退化情况2：remove树节点时，若root，root.left,root.right,root.left.left有一个为null，也会退化为链表.

   - 索引如何计算?hashCode都有了，为啥还要提供hash()方法？数组容量为何是2的n次幂？

      ① 计算对象的hashCode(),再进行调用hashMap的hash()方法进行二次哈希，最后&(capacity-1)得到索引值。

      ②  二次hash()是为了综合高位数据，让哈希分布更为均匀

      ③ 计算索引时，如果是2的n次幂可以使用位与运算代替取模,效率更高；扩容时hash&oldcap==0的元素留在原来的位置,否则新位置=旧位置+oldcap

      ④ 但①、②、③都是为了配合容量为2的n次幂时的优化手段，例如HashTable的容量就不是2的n次幂，并不能说哪种设计更优，应该是设计者综合了各种因素，最终选择使用了2的n次幂作为容量。

   - 介绍一下put方法流程,1.7与1.8有何不同?

      ① HashMap是懒惰创建的,首次使用才创建数组

      ② 计算索引（桶下标）

      ③ 如果桶下标还没人占用，创建Node占位返回

      ④ 如果桶下标已经有人占用

     ​       ① 已经是TreeNode走红黑树的添加或更新                逻辑

     ​       ② 是普通Node,走链表的添加或更新逻辑，如果链表长度超过树化阀值，走树化逻辑.

     ⑤  返回前检查容量是否超过阀值，一旦超过进行扩容

     ⑥ 不同

     ​      ① 链表插入节点时，1.7是头插法，1.8是尾插法

     ​       ② 1.7是大于等于阀值且没有空位时才扩容，1.8是大于阀值就扩容

     ​        ③ 1.8在扩容计算Node索引时，会优化
     
     
     
   - 加载因子为何默认是0.75f
   
     ① 在空间占用与查询时间之间取得较好的权衡
   
     ② 大于这个值，空间节省了，但链表就会比较      长影响性能
   
     ③ 小于这个值，冲突减少了，但扩容就会更频繁，空间占用多。
   
   - 多线程下会有啥问题?
   
     ① 扩容死链(1.7)
   
     ② 数据错乱(1,7,1.8)
   
   - key能否为null，作为key的对象有什么要求？
   
      ① HashMap的key可以为null，但Map的其他实现则不然
   
     ② 作为key的对象，必须s内容不能修改(不可变)
   
   - String对象的hashCode()如何设计，为啥每次乘的是31
   
     - 目标是达到较为均为的散列效果，每个字符串的hashCode足够独特
   
     ​    ① 字符串中的每个字符都可以表现为一个数字，称为Si，其中i的范围是0~n-1
   
     ​    ②  散列公式为 : s0**31^n-1+s1* *31^n-2+..+Sn-1* * 31^0
   
     ​    ③ 31代入公式有交换的散列特性，并且31*h可以被优化为
   
     ​            ① 即32*h-h
   
     ​            ②  即2^5*h-h
   
     ​            ③   即 h<<5-h
     
     #####  ConcurrentHashMap
     
     **底层数据结构：** JDK1.7 的 `ConcurrentHashMap` 底层采用 **分段的数组+链表** 实现，JDK1.8 采用的数据结构跟 `HashMap1.8` 的结构一样，数组+链表/红黑二叉树。
     
     **实现线程安全的方式（重要）：** ① **在 JDK1.7 的时候，`ConcurrentHashMap`（分段锁）** 对整个桶数组进行了分割分段(`Segment`)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。 **到了 JDK1.8 的时候已经摒弃了 `Segment` 的概念，而是直接用 `Node` 数组+链表+红黑树的数据结构来实现，并发控制使用 `synchronized` 和 CAS 来操作。**
     
     