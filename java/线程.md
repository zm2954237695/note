##### 1. 线程有哪些状态

 六种：

![image-20220219232111900](C:\Users\逐梦\AppData\Roaming\Typora\typora-user-images\image-20220219232111900.png)

五种：

![image-20220220172130887](C:\Users\逐梦\AppData\Roaming\Typora\typora-user-images\image-20220220172130887.png)

##### 2 线程池的核心参数

1. corePoolSize 核心线程数目
   - 最多保留的线程数
2. maximumPoolSize 最大线程数目
   - 核心线程 + 救急线程
3. keepAliveTime 生成时间
   - 针对救急线程
4. unit 时间单位
   - 针对救急线程
5. workQueue 
   - 阻塞队列
6.  threadFactory 线程工厂
   - 可以为线程创建时起个好名字
7. handler 拒绝策略
   -  四种

##### sleep vs wait

- 共同点: wait(), wait(long)和sleep(long)的效果都是让当前线程暂时放弃CPU的使用权，进入阻塞状态。

- 方法归属不同

   ① sleep(long)是Thread的方法。

   ② 而wait(),wait(long)都是Object的成员方法，每个对象都有

- 醒来时机不同

   ① 执行sleep(long)和wait(long)的线程都会在等待相应毫秒后醒来

  ② wait(long)和wait()可以被notify唤醒，wait()如果不唤醒就一直等下去

  ③ 它们都可以被打断唤醒

- 锁特性不同

   ① wait方法的调用必须先获取wait对象的锁，而sleep则无此限制

  ② wait方法执行后会释放对象锁，允许其他线程获得对象锁

  ③ 而sleep如果在synchronized代码块中执行，并不会释放对象锁。

##### lock vs synchronized

- 语法层面
  - synchronized是关键字，源码在jvm中，用c++语言实现
  - lock是接口，源码由jdk提供，用java语言实现
  - 使用synchronized时，退出同步代码块会自动释放，而使用lock时，需要手动调用unlock方法释放锁
- 功能层面
  - 二者均属于悲观锁，都具备基本的互斥、同步、锁重入功能。
  - lock提供了许多synchronized不具备的功能，例如获取等待状态、公平锁、可打断、可超时、多条件变量。
  - lock有适合不同场景的实现，如ReentranLock,ReentranReadWriteLock等
- 性能层面
  - 在没有竞争时，synchronized做了很多优化，如偏向锁、轻量级锁，性能不赖
  - 在竞争激烈时，lock的实现通常会提供更好的性能。