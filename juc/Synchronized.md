##### Synchronized

Java的线程是映射到操作系统原生线程之上的，如果要阻塞或唤醒一个线程需要操作系统介入，<font color=red>需要在用户态和内核态之间切换，这种切换换消耗大量的系统资源，</font>因为用户态与内核态都有各自专用的内存空间，专用的寄存器等，用户态切换至内核态需要传递许多变量、参数给内核，内核也需要保护好用户态在切换时的一些的寄存器值、变量等，以便用户态调用结束后切换到用户态继续工作。

在java的早期版本中，synchronized属于重量级锁，效率低下，因为监视器是依赖于底层的操作系统的Mutex来实现的。



Monitor可以理解为一种同步工具，也可以理解为一种同步机制，常常被描述为一个java对象。java对象是天生的Monitor，每个都有成为monitor的潜质。

Monitor本质是依赖是底层操作系统的Mutex Lock实现的，需要在用户态和内核态之间切换。

##### Monitor与java对象如何关联?

1. 如果一个java对象被某个线程锁住，则该对象的Mark word字段中LockWord指向monitor的起始地址。
2. Monitor的Owner字段存放拥有相关锁对象的线程id



在无锁状态下，Mark Word可以存储对象hash code值。当对象的hashCode()方法第一次被调用时，JVM会生成对应的hashcode值并将该值存储到Mark word中。

对于偏向锁，在线程获取偏向锁时，会用Thread ID和epoch值覆盖hash code所在的位置。如果一个对象的hashcode()方法已经被调用过一次，中国对象不能被设置为偏向锁。因为如果可以的话，那mark word中的hashcode必然会被偏向线程id给覆盖，这就会造成同一个对象前后两次调用hashcode（）方法得到的结果不一致。

升级为轻量级锁时，JVM会在当前线程的栈帧中创建一个锁记录空间，用于存储对象的mark word拷贝，该拷贝可以保护hash code。所以轻量级锁可以和hashcode共存，哈希码和GC年龄保存在此，释放锁后会将这些信息写回到对象头。

升级重量级锁后，Mark word保存的重量级锁指针，代表重量级锁的ObjectMonitor类里有字段记录非加锁状态下的mark word，锁释放后也会将信息写回到对象头。





当一个对象已经计算过一致性哈希码后，它就再也无法进入偏向锁状态；而一个对象当前正处于偏向锁状态，又收到需要计算其一致性哈希码请求时，它的偏向状态会立即被撤销，并且锁会膨胀为重量级锁。在重量级锁的实现中，对象头指向了重量级锁的位置，代表重量级锁的ObjectMonitor类里有字段可以记录非加锁状态下的Mark word，其中自然可以存储原来的哈希码。
