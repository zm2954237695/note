### 列表过滤

```html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<script src="../js/vue.js" type="text/javascript" charset="utf-8"></script>
	</head>
	<body>
		<div id="root">
			<h2>人员列表</h2>
			<input type="text" placeholder="请输入名字" v-model="keyword">
		   <ul>
		   	<li v-for="(p,index) of filPersons" :key="index">
				{{p.name}}-{{p.age}}
			</li>
		   </ul>
		</div>
		<script type="text/javascript">
			new Vue({
				el:'#root',
				data:{
					keyword:'',
					persons:[
						{id:'001',name:'马冬梅',age:18},
						{id:'002',name:'周冬梅',age:18},
						{id:'003',name:'网梅',age:29},
						{id:'004',name:'网红',age:29},
					],
					filPersons:[]
				},
				watch:{
					keyword:{
						immediate:true,
						handler(val){
							this.filPersons=this.persons.filter((p)=>{
								return p.name.indexOf(val)!==-1
							})
						}
					}
				}
			})
		</script>
	</body>
</html>

```

首先先通过v-model进行双向绑定，获取输入的数据存到data里面的keyword属性，然后通过watch监视属性来对输入的数据进行过滤，由于设置了immediate为true，也就是一上来就会进行一次filter的调用，也就完成了首先显示所有的用户列表.

用computed计算属性写法

```js
computed:{
					filPersons(){
					     return	this.persons.filter((p)=>{
							return p.name.indexOf(this.keyword)!=-1
						})
					}
}
				
```

列表排序



```js
computed:{
					filPersons(){
					     const arr = this.persons.filter((p)=>{
							return p.name.indexOf(this.keyword)!==-1
						})
						if(this.sortType){
							arr.sort((p1,p2)=>{
								return this.sortType===1?p2.age-p1.age:p1.age-p2.age
							})
						}
						return arr
					}
}
```

