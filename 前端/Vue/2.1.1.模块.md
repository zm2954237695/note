### 2.1.1.模块

- 理解：向外提供特定功能的js程序,一般就是一个js文件
- 为什么：js文件很多很复杂
- 作用：复用js,简化js的编写,提高js运行效率

### 2.1.2.组件

1. 理解：用来实现局部(特定)功能效果的代码集合(html/css/js/image…..)
2. 为什么：一个界面的功能很复杂
3. 作用：复用编码,简化项目编码,提高运行效率

### 2.1.3.模块化

当应用中的js都以模块来编写的,那这个应用就是一个模块化的应用。

### 2.1.4.组件化

当应用中的功能都是多组件的方式来编写的,那这个应用就是一个组件化的应用。

## 2.2.非单文件组件

1. 模板编写没有提示
2. 没有构建过程,无法将ES6转换成ES5
3. 不支持组件的CSS
4. 真正开发中几乎不用

```js
	Vue中使用组件的三大步骤：
		一、定义组件(创建组件)
		二、注册组件
		三、使用组件(写组件标签)

	一、如何定义一个组件？
		使用Vue.extend(options)创建，其中options和new Vue(options)时传入的那个options几
                乎一样，但也有点区别；
			1.el不要写，为什么？ ——— 最终所有的组件都要经过一个vm的管理，由vm中的el决定服务哪个容器
			2.data必须写成函数，为什么？ ———— 避免组件被复用时，数据存在引用关系。
			备注：使用template可以配置组件结构。

	二、如何注册组件？
		1.局部注册：靠new Vue的时候传入components选项
		2.全局注册：靠Vue.component('组件名',组件)

	三、编写组件标签(来实现组件复用)：
		<school></school> <student></student> <hello></hello>

```

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <script src="https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js"></script>
  </head>
  <body>
    <div id="root">
      <hr />
      <school></school>
      <h1>{{msg}}</h1>
      <hr />
      <student></student>
    </div>
  </body>
  <script type="text/javascript">
    Vue.config.productionTip = false;
    const school = Vue.extend({
      // el: '#root',
      template: `
       <div class="demo">
					<h2>学校名称：{{schoolName}}</h2>
					<h2>学校地址：{{address}}</h2>
					<button @click="showName()">点我提示学校名</button>	
				</div>
       `,
      data() {
        return {
          schoolName: '哈哈哈',
          address: '北京',
        };
      },
      methods: {
        showName() {
          alert(this.schoolName);
        },
      },
    });
    const student = Vue.extend({
      template: `
        <div>
          <h2>学生姓名：{{studentName}}</h2>
          <h2>学生年龄:{{studentAge}}</h2>
        </div>
      `,
      data() {
        return {
          studentName: '张三',
          studentAge: 18,
        };
      },
    });
    new Vue({
      el: '#root',
      data: {
        msg: 'Hello',
      },
      components: {
        school,
        student,
      },
    });
  </script>
</html>

```

```html
几个注意点：
	1.关于组件名:
		一个单词组成：
			第一种写法(首字母小写)：school
			第二种写法(首字母大写)：School
		多个单词组成：
			第一种写法(kebab-case命名)："my-school"
			第二种写法(CamelCase命名)：MySchool (需要Vue脚手架支持)
	备注：
		(1).组件名尽可能回避HTML中已有的元素名称，例如：h2、H2都不行。
		(2).可以使用name配置项指定组件在开发者工具中呈现的名字。
	2.关于组件标签:
		第一种写法：<school></school>
		第二种写法：<school/>
		备注：不用使用脚手架时，<school/>会导致后续组件不能渲染。
        3.一个简写方式：
		const school = Vue.extend(options) 可简写为：const school = options

```

### 2.2.3组件的嵌套

**子组件要在父组件之前定义**

```html
<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8" />
	<title>组件的嵌套</title>
	<!-- 引入Vue -->
	<script type="text/javascript" src="../js/vue.js"></script>
</head>

<body>
	<!-- 准备好一个容器-->
	<div id="root">

	</div>
</body>
<script type="text/javascript">
	Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。
	//定义student组件
	const student = Vue.extend({
		name: 'student',
		template: `
				<div>
					<h2>学生姓名：{{name}}</h2>	
					<h2>学生年龄：{{age}}</h2>	
				</div>
			`,
		data() {
			return {
				name: 'pink老师',
				age: 18
			}
		}
	})
	//定义school组件
	const school = Vue.extend({
		name: 'school',
		template: `
				<div>
					<h2>学校名称：{{name}}</h2>	
					<h2>学校地址：{{address}}</h2>	
					<student></student>
				</div>
			`,
		data() {
			return {
				name: '尚硅谷',
				address: '北京'
			}
		},
		//注册组件（局部）
		components: {
			student
		}
	})

	//定义hello组件
	const hello = Vue.extend({
		template: `<h1>{{msg}}</h1>`,
		data() {
			return {
				msg: '欢迎来到尚硅谷学习！'
			}
		}
	})

	//定义app组件
	const app = Vue.extend({
		template: `
				<div>	
					<hello></hello>
					<school></school>
				</div>
			`,
		components: {
			school,
			hello
		}
	})

	//创建vm
	new Vue({
		template: '<app></app>',
		el: '#root',
		//注册组件（局部）
		components: { app }
	})
</script>
</html>

```

### 2.2.5 一个重要的内置关系

```js
	1.一个重要的内置关系：VueComponent.prototype.__proto__ === Vue.prototype
	2.为什么要有这个关系：让组件实例对象（vc）可以访问到 Vue原型上的属性、方法。
```

### 3.2.1 脚手架文件结构

├── node_modules:各种包,库,插件
├── public
│   ├── favicon.ico: 页签图标
│   └── index.html: 主页面
├── src
│   ├── assets: 存放静态资源
│   │   └── logo.png
│   │── component: 存放组件
│   │   └── HelloWorld.vue
│   │── App.vue: 汇总所有组件
│   │── main.js: 入口文件
├── .gitignore: git版本管制忽略的配置
├── babel.config.js: babel的配置文件
├── package.json: 应用包配置文件 
├── README.md: 应用描述文件
├── package-lock.json：包版本控制文件



vue.js与vue.runtime.xxx.js的区别：

1. vue.js是完整版的Vue，包含：核心功能 + 模板解析器。
2. vue.runtime.xxx.js是运行版的Vue，只包含：核心功能；没有模板解析器。

因为vue.runtime.xxx.js没有模板解析器，所以不能使用template这个配置项，需要使用render函数接收到的createElement函数去指定具体内容。

## 3.3 ref属性

1. 被用来给元素或子组件注册引用信息（id的替代者）
2. 应用在html标签上获取的是真实DOM元素，应用在组件标签上是组件实例对象（vc）
3. 使用方式：
   1. 打标识：`<h1 ref="xxx">.....</h1>` 或 `<School ref="xxx"></School>`
   2. 获取：`this.$refs.xxx`

## 3.4 props配置项

1. 功能：让组件接收外部传过来的数据

2. 传递数据：`<Demo name="xxx"/>`

3. 接收数据：

   1. 第一种方式（只接收）：`props:['name'] `

   2. 第二种方式（限制类型）：`props:{name:String}`

   3. 第三种方式（限制类型、限制必要性、指定默认值）：

      App.vue


```vue
<template>
  <div>
    <Student name="李四" sex="女" :age="18" />
    <!-- 在组件标签中声明传入属性 
	:即v-bind 将字符串18变为js表达式，使其可以接受加法运算
	-->
  </div>
</template>
<script>
import Student from "./components/Student";
export default {
  name: "App",
  components: { Student },
};
</script>
```

**Student.vue**

```vue
<template>
  <div>
    <h1>{{ msg }}</h1>
    <h2>学生姓名：{{ name }}</h2>
    <h2>学生性别：{{ sex }}</h2>
    <h2>学生年龄：{{ myAge + 1 }}</h2>
    <button @click="updateAge">尝试修改收到的年龄</button>
  </div>
</template>

<script>
export default {
  name: "Student",
  data() {
    console.log(this);
    return {
      msg: "我是一个尚硅谷的学生",
      myAge: this.age,
       //   props的数据不允许修改，想要改动得到propo的数据放入data中
      //   props的优先级高，data中的this.age是props中接收的数据
    };
  },
  methods: {
    updateAge() {
      this.myAge++;
    },
  },
  //方法一:简单声明接收，放在组件实例对象vc上
  // props:['name','age','sex']

  //方法二:接收的同时对数据进行类型限制，类型如果不符合报错
  /* props:{
			name:String,
			age:Number,
			sex:String
		} */

  //方法三：接收的同时对数据：进行类型限制+默认值的指定+必要性的限制
  props: {
    name: {
      type: String, //name的类型是字符串
      required: true, //name是必要的，有此属性一般不需要加默认值
    },
    age: {
      type: Number,
      default: 99, //默认值，即如果不传此属性则使用默认值
    },
    sex: {
      type: String,
      required: true,
    },
  },
};
</script>

```

## 3.5mixin(混入)

1. 功能：可以把多个组件共用的配置提取成一个混入对象

2. 使用方式：

   第一步定义混合：

   ```
   {
       data(){....},
       methods:{....}
       ....
   }
   复制代码
   ```

   第二步使用混入：

- ```
  使用前需要import导入
  复制代码
  ```

- ```
  全局混入：Vue.mixin(xxx)放在main.js文件中,所有vm,vc都能得到混入的属性
  复制代码
  ```

- ```
  局部混入：mixins:['xxx']放在需要的文件中,在此文件中得到混入的属性
  复制代码
  ```

- ```
  如果混入与自身有同名属性,自身属性优先级高,会覆盖掉混入属性
  ```

  ## 3.6 插件

  1. 功能：用于增强Vue

  2. 本质：包含install方法的一个对象，install的第一个参数是Vue，第二个以后的参数是插件使用者传递的数据。

  3. 定义插件：

     ```js
     对象.install = function (Vue, options) {
         // 1. 添加全局过滤器
         Vue.filter(....)
     
         // 2. 添加全局指令
         Vue.directive(....)
     
         // 3. 配置全局混入(合)
         Vue.mixin(....)
     
         // 4. 添加实例方法
         Vue.prototype.$myMethod = function () {...}
         Vue.prototype.$myProperty = xxxx
     }
     ```

  ## 3.7 scoped样式

  如果不同组件起了相同的样式名，会造成样式冲突，在App.vue中后import导入的组件样式会覆盖前面一个组件的同名样式，所以用scoped解决。最好不要再App.vue的style中加入scoped，因为他是汇总组件，写在其中的样式为公共样式。

  1. 作用：让样式在局部生效，防止冲突。
  2. 写法：


  ```js
  <style lang="less" scoped> 
  //lang =''规定了用什么来写style，不写默认为css
  	.demo{
  		background-color: pink;
  	}
  </style>
  
  ```

  
