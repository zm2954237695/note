### 计算机操作系统 - 进程管理

#### 进程与线程

##### 1. 进程

 进程是资源分配的基本单位。

进程控制块(PCB)描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对PCB进行操作。

##### 2.线程

线程是独立调度的基本单位。

一个进程中可以有多个线程，它们共享进程资源。

> e.g:QQ 和浏览器是两个进程，浏览器进程里面有很多线程，例如 HTTP 请求线程、事件响应线程、渲染线程等等，线程的并发执行使得在浏览器中点击一个新链接从而发起 HTTP 请求时，浏览器还可以响应用户的其它事件。

##### 3. 区别

I 拥有资源

进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。

II 调度

线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。

III 系统开销

由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间，I/O设备等，所付出的开销远大于创建线程的开销。类似地，由于进行进程切换时，涉及当前执行进程CPU环境的保存以及新调度进程CPU的设置，而线程切换只需保存和设置少量寄存器的内容，开销很小。

IV 通信方面

线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助IPC。

## 进程状态的切换

- 就绪状态（ready）：等待被调度
- 运行状态（running）
- 阻塞状态（waiting）：等待资源

应该注意以下内容:

- 只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。
- 阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。

#### 进程调度算法

不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。

##### 1. 批处理系统

批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间(从提交到终止的时间).

###### 1.1先来先服务(FCFS)

非抢占式的调度算法，按照请求的顺序进行调度。

有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。

###### 1.2短作业优先(SJF)

非抢占式的调度算法，按估计运行时间最短的顺序进行调度。

长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。

###### 1.3最短剩余时间优先

最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。

##### 2. 交互式系统

交互式系统中有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。

###### 2.1时间片轮转

将所有就绪进程按FCFS的原则排成一个队列，每次调度时，把CPU时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并把它送完就绪队列的末尾，同时继续把CPU时间分配给队首的进程。

时间片轮转算法的效率和时间片的大小有很大关系:

- 因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上会过多时间。
- 如果时间片过长，那么实时性就得不到保证。

 ![img](https://camo.githubusercontent.com/a87daa8201015ff54a213d9ea95c1e49e7eec447938c441dd0247e80b18eaa05/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f38633636323939392d633136632d343831632d396634302d3166646261356263393136372e706e67)

###### 2.2 优先级调度

为每个进程分配一个优先级，按优先级进行调度。

为了防止低优先级的进程永远得不到调度，可以随着时间的推移增加等待进程的优先级。

###### 2.3 多级反馈队列

一个进程需要执行100个时间片，如果采用时间片轮转算法，那么需要交换100次。

多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如1,2,4,8...进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换7次。

每个队列优先权不同，最上面的优先权最高。因此只有当上一个队列没有进程在排队，才能调度当前队列上的进程。

可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。

![img](https://camo.githubusercontent.com/c20fd7a3268ebc4ef0bce390344de2c5358392ecef2413d849c3095e21047980/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f30343263663932382d336338652d343831352d616539632d6632373830323032633638662e706e67)

##### 3.实时系统

实时系统要求一个请求在一个确定时间内得到响应。

分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。

#### 进程同步

##### 1.临界区

对临界资源进行访问的那段代码称为临界区。

为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。

```pascal
// entry section
// critical section;
// exit section
```

##### 2.同步与互斥

- 同步:多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。
- 互斥:多个进程在同一个时刻只有一个进程进入临界区。

##### 3. 信号量

信号量是一个整型变量，可以对其执行down和up操作，也就是P和V操作。

- down:如果信号量大于0，执行-1操作。如果信号量等于0，进程睡眠。等待信号量大于0.
- up：对信号量执行+1操作，唤醒睡眠的进程让其完成down操作。

down和up操作需要被设计成原语，不可分割。通常的做法是在执行这些操作的时候屏蔽中断。

如果信号量的取值只能为0或1，就成为了***互斥量***。0表示临界区已经加锁，1表示临界区解锁。

```c
typedef int semaphore;
semaphore mutex = 1;
void P1() {
    down(&mutex);
    // 临界区
    up(&mutex);
}

void P2() {
    down(&mutex);
    // 临界区
    up(&mutex);
}

```

##### 使用信号量来实现生产者-消费者问题

问题描述：使用一个缓冲区来保存物品，只有缓冲区没有满，生产者才可以放入物品；只有缓冲区不为空，消费者才可以拿走物品。

因为缓冲区属于临界资源，因此需要使用一个互斥量mutex来控制对缓冲区的互斥访问。

为了同步生产者和消费者的行为，需要记录缓冲区中物品的数量。数量可以使用信号量来进行统计，这里需要使用两个信号量:empty记录空缓冲区的数量，full记录满缓冲区的数量。其中，empty信号量是在生产者进程中使用，当empty不为0时，生产者才可以放入物品;full信号量在消费者进程中使用，当full信号量不为0，消费者才能驱走物品。

注意，不能先对缓冲区进行加锁，再测试信号量。也就是不能先执行down(mutex),再执行down(empty)。如果这么做，那么可能出现这种情况:生产者对缓存区加锁后，执行down(mutex)操作，发现empty=0，此时生产者进程阻塞。消费者进程不能进入临界区，因为生产者对缓冲区加锁了，消费者就无法执行up(empty)操作，empty永远为0，导致生产者永远停下，不会释放锁，消费者也将因此永远等待下去。

```c
void producer(){
    while(true){
        int item = produce_item();
        down(&empty);
        down(&mutex);
        insert_item(item);
        up(&mutex);
        up(&full);
    }
}
void consumer(){
   while(true){
       down(&full);
       down(&mutex);
       int item = remove_item();
       consume_item(item);
       up(&mutex);
       up(&empty);
   }
}
```

##### 4.管程

使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。

c 语言不支持管程，下面的示例代码使用了类 Pascal 语言来描述管程。示例代码的管程提供了 insert() 和 remove() 方法，客户端代码通过调用这两个方法来解决生产者-消费者问题。

```pascal
monitor ProducerConsumer
    integer i;
    condition c;

    procedure insert();
    begin
        // ...
    end;

    procedure remove();
    begin
        // ...
    end;
end monitor;

```

管程有一个重要特性:在一个时刻只能有一个进程使用管程。进程在无法继续执行的时候不能一直占用管程，否则其他进程永远不能使用管程。

管程引入了 **条件变量** 以及相关的操作：**wait()** 和 **signal()** 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。

```pascal
// 管程
monitor ProducerConsumer
    condition full, empty;
    integer count := 0;
    condition c;

    procedure insert(item: integer);
    begin
        if count = N then wait(full);
        insert_item(item);
        count := count + 1;
        if count = 1 then signal(empty);
    end;

    function remove: integer;
    begin
        if count = 0 then wait(empty);
        remove = remove_item;
        count := count - 1;
        if count = N -1 then signal(full);
    end;
end monitor;

// 生产者客户端
procedure producer
begin
    while true do
    begin
        item = produce_item;
        ProducerConsumer.insert(item);
    end
end;

// 消费者客户端
procedure consumer
begin
    while true do
    begin
        item = ProducerConsumer.remove;
        consume_item(item);
    end
end;

```

## 经典同步问题

五个哲学家围着一张圆桌，每个哲学家面前放着食物。哲学家的生活有两种交替活动：吃饭以及思考。当一个哲学家吃饭时，需要先拿起自己左右两边的两根筷子，并且一次只能拿起一根筷子。

下面是一种错误的解法，如果所有哲学家同时拿起左手边的筷子，那么所有哲学家都在等待其它哲学家吃完并释放自己手中的筷子，导致死锁。

```c
#define N 5

void philosopher(int i) {
    while(TRUE) {
        think();
        take(i);       // 拿起左边的筷子
        take((i+1)%N); // 拿起右边的筷子
        eat();
        put(i);
        put((i+1)%N);
    }
}
```

为了防止死锁的发生，可以设置两个条件：

- 必须同时拿起左右两根筷子；
- 只有在两个邻居都没有进餐的情况下才允许进餐。

```c
#define N 5
#define LEFT (i+N-1)%N //左邻居
#define RIGHT (i+1)%N  //右邻居
#define THINKING 0
#define HUNGRY 1
#define EATING 2
typedef int semaphore;
int state[N];//跟踪每个哲学家的状态
semaphore mutex = 1; //临界区的互斥，临界区是state数组，对其修改需要互斥
semaphore s[N];//每个哲学家一个信号量
void philosopher(int i){
    while(TRUE){
        think(i);
        take_two(i);
        eat(i);
        put_two(i);
    }
}
void take_two(int i){
    down(&mutex);
    state[i] = HUNGRY;
    check(i);
    up(&metux);
    down(&s[i]);
}
void put_two(i) {
    down(&mutex);
    state[i] = THINKING;
    check(LEFT); // 尝试通知左右邻居，自己吃完了，你们可以开始吃了
    check(RIGHT);
    up(&mutex);
}
void eat(int i) {
    down(&mutex);
    state[i] = EATING;
    up(&mutex);
}

// 检查两个邻居是否都没有用餐，如果是的话，就 up(&s[i])，使得 down(&s[i]) 能够得到通知并继续执行
void check(i) {         
    if(state[i] == HUNGRY && state[LEFT] != EATING && state[RIGHT] !=EATING) {
        state[i] = EATING;
        up(&s[i]);
    }
}
```

### 2. 读者-写者问题

允许多个进程同时对数据进行读操作，但是不允许读和写以及写和写操作同时发生。

由于写进程与任何进程都互斥，因此需要一个互斥变量data_mutex，在写者访问共享变量前后都需要进行PV操作，读者进程和写者进程也是互斥的，因此读者在访问共享变量时，也要对data_mutex进行PV操作。但是如果对所有的读者进程在访问共享变量时都进行PV操作时，那么将导致多个读者进程不能同时访问共享文件。我们可以让第一个读进程负责对变量进行加锁，而最后一个读者进程对变量解锁，表示读过程结束，增加一个变量count表示有多少个读进程在访问文件。如果两个读进程并发执行，则两个读进程有可能先后执行p(rw),导致第二个进程阻塞。出现该问题的**原因在于对count变量的检查和赋值无法一气呵成**。因此可以在对count检查和赋值的代码进行加锁，不过这样可能会出现写进程“饿死",因为只要有读进程，写进程就要一直阻塞等待。读进程是优先的。那么如何解决这个问题呢，引入新的互斥信号量w。该算法实现的不是绝对的公平，而是按照先来先服务。写进程不会饿死。

一个整型变量 count 记录在对数据进行读操作的进程数量，一个互斥量 count_mutex 用于对 count 加锁，一个互斥量 data_mutex 用于对读写的数据加锁。

```c
typedef int semaphore;
semaphore count_mutex = 1;
semaphore data_mutex = 1;
int count = 0;

void reader() {
    while(TRUE) {
        down(w)
        down(&count_mutex);
        count++;
        if(count == 1) 
            down(&data_mutex); // 第一个读者需要对数据进行加锁，防止写进程访问
        up(&count_mutex);
        up(w)
        read();
        down(&count_mutex);
        count--;
        if(count == 0) up(&data_mutex);
        up(&count_mutex);
    }
}

void writer() {
    while(TRUE) {
        down(w)
        down(&data_mutex);
        write();
        up(&data_mutex);
        up(w)
    }
}
```

