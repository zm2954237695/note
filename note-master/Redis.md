#### Redis

##### 缓存雪崩 

当某一个时刻出现大规模的缓存失效的情况，那么就会导致大量的请求直接打在数据库上面，导致数据库压力巨大，如果在高并发的情况下，可能瞬间就会导致数据库宕机。

解决方案：

1. 在原有的失效时间上加上一个随机值，比如1-5分钟随机。这样就避免了因为采用相同的过期时间导致的缓存雪崩。
2. 使用熔断机制。当流量到达一定的阈值时，就直接返回“系统拥挤”之类的提示，防止过多的请求打在数据库上。至少能保证一部分用户是可以正常使用，其他用户多刷新几次也能得到结果。
3. 提高数据库的容灾能力，可以使用分库分表，读写分离的策略。
4. 为了防止Redis宕机导致缓存雪崩的问题，可以搭建Redis集群，提高Redis的容灾性。

##### 缓存击穿

缓存击穿是一个热点的Key，有大并发集中对其进行访问，突然间这个Key失效了，导致大并发全部打在数据库上，导致数据库压力剧增

解决方案：

1. 对于热点的key条件允许时，可以设置永不过期。
2. 使用互斥锁。如果缓存失效的情况，只有拿到锁才能查询数据库，降低了在同一时刻打在数据库上的请求，防止把数据库打死。

##### 缓存穿透

发送的请求传进来的key是不存在redis中的，那么就查不到缓存，查不到缓存就会查询数据库。假设有大量这样的请求，这些请求会像"穿透"了缓存一样直接打在了数据库上。

**解决方案：**

1、**把无效的Key存进Redis中**。如果Redis查不到数据，数据库也查不到，我们把这个Key值保存进Redis，设置value="null"，当下次再通过这个Key查询时就不需要再查询数据库。这种处理方式肯定是有问题的，假如传进来的这个不存在的Key值每次都是随机的，那存进Redis也没有意义。

2、**使用布隆过滤器**。布隆过滤器的作用是某个 key 不存在，那么就一定不存在，它说某个 key 存在，那么很大可能是存在(存在一定的误判率)。于是我们可以在缓存之前再加一层布隆过滤器，在查询的时候先去布隆过滤器查询 key 是否存在，如果不存在就直接返回。

##### 布隆过滤器

核心实现是一个超大的位数组和几个哈希函数。

**布隆过滤器添加元素**

- 将要添加的元素给k个哈希函数
- 得到对应于位数组的k个位置
- 将这k个位置置为1

**布隆过滤器查询元素**

- 将要查询的元素给k个哈希函数
- 得到对应于位数组上的k个位置
- 如果k个位置有一个为0，那么肯定不在集合中
- 如果k个位置全部为1，那可能在集合中。(存在误判)

##### 为什么Redis是单线程？

1. 不需要各种锁的性能消耗

   <font size=1>Redis的数据结构并不全是简单的Key-Value，还有list，hash等复杂的结构，这些结构有可能会进行很细粒度的操作，比如在很长的列表后面添加一个元素，在hash当中添加或者删除一个对象。这些操作可能就需要加非常多的锁，导致的结果是同步开销大大增加。</font>

2. 单线程多进程集群方案

   <font size=1>单线程的威力实际上非常强大，单核cpu效率也非常高，多线程自然是可以比单线程有更高的性能上限，但是在今天的计算环境中，即使是单机多线程的上限也往往不能满足需要了，需要进一步摸索的是多服务器集群化的方案，这些方案中多线程的技术照样是用不上的。</font>

3. CPU消耗

   <font size=1>采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU。</font>

   

   

   

   

   

   

   

   

   











