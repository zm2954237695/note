##### java对象的布局

1. 在JVM中，对象在内存中的布局分为三块区域：对象头、实例数据和对齐填充数据

2.  <font size=3>对象头包括Mark Word+类型指针</font>

   

​    <font size=1>Mark World用于存储对象自身的运行时数据，如哈希码，GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，占用内存大小和虚拟机位长一致。类型指针用于存储对象的类型指针，该指针指向它的类元数据，jvm通过这个指针确定对象是哪个类的实例。</font>

3. 实例数据

   <font size=1>就是类中定义的成员变量。</font>

4. 对齐填充

   <font size=1>对齐填充并不是必然存在的，也没有什么特别的意义，他仅仅起着占位符的作用，由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说，就是对象的大小必须是8字节的整数倍</font>

​       当一个线程尝试访问synchronized修饰的代码块      时，它首先要获得锁，这个锁是存在锁对象的对象头中的。

##### 偏向锁

在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低，引进了偏向锁。

这个锁会偏向于第一个获得它的线程，会在对象头存储锁偏向的线程ID，以后该线程进入和退出同步块时只需要检查是否为偏向锁、锁标志位以及ThreadID即可。

不过一旦出现多个线程竞争时必须撤销偏向锁，所以撤销偏向锁消耗的性能必须小于之前节省下来的CAS原子操作的性能消耗，不然就得不偿失了。

**原理**

- 虚拟机会将对象头的标志位设为"01",即偏向模式
- 同时使用CAS操作把获取到这个锁的线程的ID记录在对象的Mark Word中，如果CAS操作成功，持有偏向锁的线程以后每进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作，偏向锁的效率高。

##### 轻量级锁

引入轻量级锁的目的：在多线程交替执行同步块的情况下，尽量避免重量级锁引起的性能消耗，但是如果多个线程在同一时刻进入临界区，会导致轻量级锁膨胀升级重量级锁，所以轻量级锁的出现并非是要替代重量级锁。当关闭偏向锁功能或者多个线程竞争偏向锁导致偏向锁升级为轻量级锁，则会尝试获取轻量级锁

**原理**

1. 判断当前对象是否处于无锁状态，如果是，则jvm首先在当前线程的栈帧中建立一个名为锁记录的空间，用于存储对象目前的Mark word的拷贝，将对象的Mark word复制到栈帧的Lock Record中，将Lock Record的owner指向当前对象。
2. JVM利用CAS操作尝试将对象的Mark Word更新为执行Lock Record的指针，如果成功表示竞争到锁，则将锁标志位变成00，执行同步操作。
3. 如果失败则判断当前对象的Mark Word是否指向当前线程的栈帧，如果是则表示当前线程已经持有当前对象的锁，则直接执行同步代码块；否则只能说明该锁对象已经被其他线程抢占了，这是轻量级锁需要膨胀为重量级锁，锁标志编程10，后面等待的线程将进入阻塞状态。

**好处**

在多线程交替执行同步块的情况下，可以避免重量级锁引起的性能消耗。

##### 自旋锁

monitor会阻塞和唤醒线程，线程的阻塞和唤醒需要CPU从用户态转为核心态，频繁的阻塞和唤醒对CPU来说是一件负担很重的工作，这些操作给系统的并发性能带来了很大的压力。同时，共享数据的锁定状态只会持续很短的一段时间，为了这段时间阻塞和唤醒线程并不值得，因此采用多次尝试的方式而不是进入阻塞，可以避免用户态与内核态的切换。

**特点**

如果锁被占用的时间很短，自旋等待的效果就会非常好，反之，如果锁被占用的时间很长。那么自旋的线程只会白白消耗处理器资源，而不会做任何有用的工作，反而会带来性能上的浪费。

##### 适应性自旋锁

自适应意味着自旋的时间不再固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋.

##### 锁消除

锁消除是指虚拟机即时编译器（JIT）在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判定依据来源于逃逸分析的数据支持.

##### 锁粗化

　原则上，我们在编写代码的时候，总是推荐将同步块的作用范围限制得尽量小，只在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变小，如果存在锁竞争，那等待锁的线程也能尽快拿到锁。大部分情况下，上面的原则都是正确的，但是如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。



